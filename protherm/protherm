#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ProTherm -- Pogrammable Thermostat for the Raspberry Pi.

Developed and tested on the following hardware:

  * Raspberry Pi model B
  * PCD8544 LCD graphical display 84x48 (Nokia 5110-3310)
  * Temperature sensor DS18B20
  * Relay Board and push button to be connected to the GPIOs
  * WiFi USB dongle

ProTherm is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

ProTherm is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public
License along with ProTherm. If not, see
<http://www.gnu.org/licenses/>.

protherm (0.9.0)
  * Can use both the new library adafruit_pcd8544 or the old
    Adafruit_Nokia_LCD (lower CPU usage).
  * Moved configuration into a single global class instead of
    global variables.
 -- Niccolo Rigacci <niccolo@rigacci.org>

protherm (0.8.0)
  * Porting code to Python 3.
  * Upgrade LCD library to adafruit_pcd8544.
 -- 2021-08-09

protherm (0.7.5)
 -- 2016-01-31

Required Debian packages:
  * python3-daemon
  * python3-lockfile
  * python3-netifaces
  * python3-ntplib
  * python3-pil
  * python3-rpi.gpio

Required pip packages:
  * adafruit-circuitpython-pcd8544

python-daemon:
https://www.python.org/dev/peps/pep-3143/
http://python-daemon.sourcearchive.com/documentation/1.5.5-1/

Timer:
http://stackoverflow.com/questions/8600161/executing-periodic-actions-in-python

PCD8544 LCD display with the old Adafruit Nokia LCD library:
https://github.com/adafruit/Adafruit_Nokia_LCD/

PCD8544 LCD display with the new Adafruit_CircuitPython_PCD8544 library:
https://github.com/adafruit/Adafruit_CircuitPython_PCD8544/
https://learn.adafruit.com/nokia-5110-3310-monochrome-lcd/

GPIO programming:
http://makezine.com/projects/tutorial-raspberry-pi-gpio-pins-and-python/

Relay:
http://arduino-info.wikispaces.com/RelayIsolation

Temperature sensor DS18B20 (range from -55°C to +125°C):
https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/temperature/

Buttons:
http://sourceforge.net/p/raspberry-gpio-python/wiki/Inputs/
"""

import configparser
import daemon
import daemon.pidfile
import signal
import threading
import logging, logging.handlers
import bisect
import netifaces
import ntplib
import os, re, sys, tempfile, time
import socket
import socketserver

import RPi.GPIO as GPIO

# Defer modules loading into the object class.
#import board
#import busio
#import digitalio
#import adafruit_pcd8544

# Defer modules loading into the object class.
#import Adafruit_Nokia_LCD as LCD
#import Adafruit_GPIO.SPI as SPI

from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont

__author__ = "Niccolo Rigacci"
__copyright__ = "Copyright 2015-2022 Niccolo Rigacci <niccolo@rigacci.org>"
__license__ = "GPLv3-or-later"
__email__ = "niccolo@rigacci.org"
__version__ = "0.9.0"

#-------------------------------------------------------------------------
# Global contants.
#-------------------------------------------------------------------------
# This is the program name.
PROG_NAME = "protherm"
# Read runtime and other configuration from this file.
CFG_FILE = "/etc/%s.cfg" % (PROG_NAME,)

DEFINED_LOGLEVELS = {
    "NOTSET":   logging.NOTSET,
    "DEBUG":    logging.DEBUG,
    "INFO":     logging.INFO,
    "WARNING":  logging.WARNING,
    "ERROR":    logging.ERROR,
    "CRITICAL": logging.ERROR
}

#-------------------------------------------------------------------------
# Other configuration.
#-------------------------------------------------------------------------
# Two manual modes (off, on), others are program modes.
MODES = {0: "MANUAL OFF", 1: "MANUAL ON", 2: "PROG1", 3: "PROG2", 4: "PROG3"}
MANUAL_MODES = [0, 1]
MODE_MANUAL_OFF = 0
MODE_DEFAULT = 2

# Idle loop duration (seconds): latency on signal handling.
IDLE_LOOP_TIME = 15

# Warning if NTP reference time is older than NTP_MAX_AGE seconds.
NTP_MAX_AGE = 14400

#-------------------------------------------------------------------------
# System configuration.
#-------------------------------------------------------------------------
PID_FILE  = "/var/run/%s.pid" % (PROG_NAME)
SHM_DIR   = "/run/shm/%s" % (PROG_NAME)         # Use shared memory!
SHM_STATS = "stats"                             # Statistics file
SHM_RRA   = os.path.join(SHM_DIR, "rra")        # Round Robin Archive
SHM_IMG   = os.path.join(SHM_DIR, "lcd.png")    # Exported image of LCD
FONTS_DIR = "/usr/local/share/fonts"
ICONS_DIR = "/usr/local/share/icons"
DATA_DIR  = "/usr/local/lib/%s" % (PROG_NAME)
CURR_MODE = "current_mode"
# Where to read networking stats.
IFACE_CARRIER = '/sys/class/net/%s/carrier'
WIFI_DATA = '/proc/net/wireless'

#-------------------------------------------------------------------------
# Global variables.
#-------------------------------------------------------------------------
cfg = None
lcd = None
thermostat = None

#-------------------------------------------------------------------------
# Class object to store thermostat internal data.
#-------------------------------------------------------------------------
class protherm():

    def __init__(self):
        # Request to terminate the program.
        self.exit_program = False
        # Current mode, used as an index of MODES array.
        self.current_mode = None
        # Programs loaded from files, indexed by current_mode.
        self.programs = {}
        # Network info.
        self.network_iface = None
        self.network_addr = None
        self.network_strength = None
        # Temperature gauge info.
        self.gauge1_value = None
        self.gauge1_required = None
        # Switch info.
        self.switch1_state = None
        self.switch1_last_change = None
        # Press button info.
        self.button1_last_press = None
        # Status of Network Time Protocol: "NTP_OK", "NTP_WARNING" or "NTP_ERROR"
        self.ntp_status = 'NTP_OK'


#-------------------------------------------------------------------------
# Class object to read configuration file and store options value.
#-------------------------------------------------------------------------
class read_config():

    def __init__(self, config_file):
        # Dictionary of config defaults (require all string values).
        CONFIG_DEFAULTS = {
            # Temperature sensor device ID.
            "TEMP_SENSOR": '/sys/bus/w1/devices/28-0000067bc546/w1_slave',
            # PCD8544 LCD settings and Raspberry Pi SPI pin connections.
            "LCD_ENABLED": 'True',
            "LCD_BIAS": '5',
            "LCD_CONTRAST": '55',
            # GPIO used for SPI Data/Command
            "LCD_DC": '23',
            # GPIO used for SPI Chip Select
            "LCD_CS": '8',
            # GPIO used for SPI Reset
            "LCD_RST": '24',
            "LCD_SPI_DEVICE": '0',
            "LCD_SPI_PORT": '0',
            "LCD_WHITE": '255',
            "LCD_BLACK": '0',
            # GPIO connected to button
            "BUTTON1_GPIO": '2',
            "BUTTON1_ENABLED": 'True',
            # Button connects the GPIO to 3.3 v (active high) or to ground.
            "BUTTON1_ACTIVE_HIGH": 'False',
            # GPIO connected to switch relays.
            "SWITCH1_GPIO": '14',
            "SWITCH2_GPIO": '15',
            # Relay module board uses "active high" signaling.
            "RELAY_ACTIVE_HIGH": 'False',
            # Networking.
            "WIRED_IFACE": 'eth0',
            "WIFI_IFACE": 'wlan0',
            # Link quality reported by iwconfig, usually is 100-based.
            "WIFI_QUALITY_SCALE": '100',
            # Default temperature if no program is defined for a given time.
            "DEFAULT_TEMPERATURE": '15',
            # Switch to DEFAULT_TEMPERATURE if NTP status is "NTP_ERROR".
            "NTP_IS_MANDATORY": 'True',
            # Use Celsius or Fahrenheit ("C" or "F").
            "DEGREES_UNIT": 'C',
            # Hysteresis times before changing switch state.
            # Hysteresis in program mode.
            "SWITCH1_HYSTERESIS": '300',
            # Hysteresis in manual (ON/OFF) mode.
            "MANUAL_HYSTERESIS": '20',
            # Hysteresis after pressing button.
            "BUTTON1_HYSTERESIS": '20',
            # Programmed temperature hysteresis for changing switch state.
            "TEMP_HYSTERESIS": '0.2',
            # Run as a daemon and logging options.
            "BE_DAEMON": 'True',
            # From logging module: NOTSET, DEBUG, INFO, WARNING, ERROR, CRITICAL.
            "LOG_LEVEL": 'INFO',
            # False for syslog logging, filename for file logging.
            "LOG_TO_FILE": 'False',
            "LOG_FORMAT": '%(asctime)s %(module)s: %(levelname)s %(message)s',
            "LOG_FMT_DATE": '%Y-%m-%d %H:%M:%S',
            # Listen to TCP port for commands.
            "BIND_ADDR": '127.0.0.1',
            "TCP_PORT": '7438',
            # Use the old Adafruit_Nokia_LCD instead of adafruit_pcd8544.
            "OLD_LCD_LIBRARY": 'False'
        }
        logging.info('Reading configuration file')
        # Parse configuration file. We use just one [PROG_NAME] section.
        config = configparser.ConfigParser(interpolation=None)
        config['DEFAULT'] = CONFIG_DEFAULTS
        config.read(config_file)
        if not PROG_NAME in config.sections():
            config.add_section(PROG_NAME)
        self.TEMP_SENSOR         = config.get(PROG_NAME, "TEMP_SENSOR")
        self.LCD_ENABLED         = config.getboolean(PROG_NAME, "LCD_ENABLED")
        self.LCD_BIAS            = config.getint(PROG_NAME, "LCD_BIAS")
        self.LCD_CONTRAST        = config.getint(PROG_NAME, "LCD_CONTRAST")
        self.LCD_DC              = config.getint(PROG_NAME, "LCD_DC")
        self.LCD_CS              = config.getint(PROG_NAME, "LCD_CS")
        self.LCD_RST             = config.getint(PROG_NAME, "LCD_RST")
        self.LCD_SPI_DEVICE      = config.getint(PROG_NAME, "LCD_SPI_DEVICE")
        self.LCD_SPI_PORT        = config.getint(PROG_NAME, "LCD_SPI_PORT")
        self.LCD_BLACK           = config.getint(PROG_NAME, "LCD_BLACK")
        self.LCD_WHITE           = config.getint(PROG_NAME, "LCD_WHITE")
        self.BUTTON1_GPIO        = config.getint(PROG_NAME, "BUTTON1_GPIO")
        self.BUTTON1_ENABLED     = config.getboolean(PROG_NAME, "BUTTON1_ENABLED")
        self.BUTTON1_ACTIVE_HIGH = config.getboolean(PROG_NAME, "BUTTON1_ACTIVE_HIGH")
        self.SWITCH1_GPIO        = config.getint(PROG_NAME, "SWITCH1_GPIO")
        self.SWITCH2_GPIO        = config.getint(PROG_NAME, "SWITCH2_GPIO")
        self.RELAY_ACTIVE_HIGH   = config.getboolean(PROG_NAME, "RELAY_ACTIVE_HIGH")
        self.WIRED_IFACE         = config.get(PROG_NAME, "WIRED_IFACE")
        self.WIFI_IFACE          = config.get(PROG_NAME, "WIFI_IFACE")
        self.WIFI_QUALITY_SCALE  = config.getint(PROG_NAME, "WIFI_QUALITY_SCALE")
        self.DEFAULT_TEMPERATURE = config.getfloat(PROG_NAME, "DEFAULT_TEMPERATURE")
        self.NTP_IS_MANDATORY    = config.getboolean(PROG_NAME, "NTP_IS_MANDATORY")
        self.DEGREES_UNIT        = config.get(PROG_NAME, "DEGREES_UNIT")
        self.SWITCH1_HYSTERESIS  = config.getint(PROG_NAME, "SWITCH1_HYSTERESIS")
        self.MANUAL_HYSTERESIS   = config.getint(PROG_NAME, "MANUAL_HYSTERESIS")
        self.BUTTON1_HYSTERESIS  = config.getint(PROG_NAME, "BUTTON1_HYSTERESIS")
        self.TEMP_HYSTERESIS     = config.getfloat(PROG_NAME, "TEMP_HYSTERESIS")
        self.BE_DAEMON           = config.getboolean(PROG_NAME, "BE_DAEMON")
        self.LOG_LEVEL           = config.get(PROG_NAME, "LOG_LEVEL")
        self.LOG_TO_FILE         = config.get(PROG_NAME, "LOG_TO_FILE")
        self.LOG_FORMAT          = config.get(PROG_NAME, "LOG_FORMAT")
        self.LOG_FMT_DATE        = config.get(PROG_NAME, "LOG_FMT_DATE")
        self.BIND_ADDR           = config.get(PROG_NAME, "BIND_ADDR")
        self.TCP_PORT            = config.getint(PROG_NAME, "TCP_PORT")
        self.OLD_LCD_LIBRARY     = config.getboolean(PROG_NAME, "OLD_LCD_LIBRARY")
        # Convert some options from str to proper data type.
        self.LOG_LEVEL = DEFINED_LOGLEVELS[self.LOG_LEVEL]
        if self.LOG_TO_FILE.lower() == "false":
            self.LOG_TO_FILE = False
        if self.DEGREES_UNIT != "F":
            self.DEGREES_UNIT = "C"
        # Realy state: can be active-high or active-low.
        self.RELAY_ON  = self.RELAY_ACTIVE_HIGH
        self.RELAY_OFF = not self.RELAY_ACTIVE_HIGH


#-------------------------------------------------------------------------
# Execute the callback function forever at specified intervals.
#-------------------------------------------------------------------------
class forever_timer:

    def __init__(self, name, interval, callback, *argv):
        self.name = name
        self.base_interval = interval
        self.callback = callback
        self.argv = argv
        logging.info(f'Starting forever_timer "{self.name}"')
        self.running = True
        self.next_time = time.time() + self.base_interval
        self.timer = threading.Timer(self.base_interval, self.execute)
        self.timer.start()

    def execute(self):
        logging.debug(f'Executing forever_timer "{self.name}"')
        self.callback(*self.argv)
        if self.running:
            self.next_time += self.base_interval
            interval = self.next_time - time.time()
            if interval <= 0:
                logging.warning(f'Timer "{self.name}": callback too slow or interval too short')
                interval = self.base_interval
                self.next_time = time.time() + interval
            self.timer = threading.Timer(interval, self.execute)
            self.timer.start()

    def stop(self):
        logging.info(f'Stopping forever_timer "{self.name}"')
        if self.running:
            self.running = False
            self.timer.cancel()


#-------------------------------------------------------------------------
# Class to handle the PCD8544 LCD display (new adafruit_pcd8544 library).
#-------------------------------------------------------------------------
class lcd_pcd8544:

    def __init__(self, cfg):
        logging.info('Using adafruit_pcd8544 library')
        import board
        import busio
        import digitalio
        import adafruit_pcd8544
        BOARD_GPIO = {
            2:  board.D2, 3:  board.D3, 4:  board.D4,
            7:  board.D7, 8:  board.D8, 9:  board.D9,
            10: board.D10, 11: board.D11, 14: board.D14,
            15: board.D15, 17: board.D17, 18: board.D18,
            22: board.D22, 23: board.D23, 24: board.D24,
            25: board.D25, 27: board.D27
        }
        self.device = '/dev/spidev%d.%d' % (cfg.LCD_SPI_DEVICE, cfg.LCD_SPI_PORT)
        self.enabled = cfg.LCD_ENABLED
        self.black = cfg.LCD_BLACK
        self.white = cfg.LCD_WHITE
        if self.enabled and not os.access(self.device, os.W_OK):
            logging.error('Device %s is not accessible, disabling LCD' % (self.device,))
            self.enabled = False
        if self.enabled:
            spi = busio.SPI(board.SCK, MOSI=board.MOSI)
            dc = digitalio.DigitalInOut(BOARD_GPIO[cfg.LCD_DC])
            cs = digitalio.DigitalInOut(BOARD_GPIO[cfg.LCD_CS])
            reset = digitalio.DigitalInOut(BOARD_GPIO[cfg.LCD_RST])
            self.pcd8544 = adafruit_pcd8544.PCD8544(spi, dc, cs, reset)
            self.reset(force_show=True)
            self.width = self.pcd8544.width
            self.height = self.pcd8544.height
        else:
            self.width = 84
            self.height = 48
        # Create an image buffer and get the drawable object.
        self.image = Image.new('1', (self.width, self.height))
        self.draw = ImageDraw.Draw(self.image)
        # Draw a white filled box to clear the image.
        self.draw.rectangle((0, 0, self.width, self.height), outline=self.white, fill=self.white)
        # Load some fonts.
        self.font_bcmp16 = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_compressed_bold.ttf'), 16)
        self.font_bcnd16 = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_condensed_bold.ttf'),  16)
        self.font_bcmp8  = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_compressed_bold.ttf'),  8)
        self.font_bcnd8  = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_condensed_bold.ttf'),   8)
        self.font_cnd8   = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_condensed.ttf'),        8)
        # Load some icons and convert to 1 bit color.
        self.icon = {}
        self.icon['fire']    = Image.open(os.path.join(ICONS_DIR, 'fire.ppm')).convert(mode='1')
        self.icon['blank']   = Image.open(os.path.join(ICONS_DIR, 'blank.ppm')).convert(mode='1')
        self.icon['ethlink'] = Image.open(os.path.join(ICONS_DIR, 'ethlink.ppm')).convert(mode='1')
        for n in (0, 25, 50, 75, 100):
            icon = 'signal%03d' % (n,)
            file = 'signal%03d.ppm' % (n,)
            self.icon[icon] = Image.open(os.path.join(ICONS_DIR, file)).convert(mode='1')
        # Threading semaphore to access the LCD.
        self.sema = threading.BoundedSemaphore()
        self.show_image()
        self.redraw_network_data = True

    def reset(self, force_show=False):
        # Sometimes the LCD gets corrupted (power problem?): workaround.
        if self.enabled:
            logging.debug('Reset LCD display')
            self.redraw_network_data = True
            self.pcd8544.reset()
            self.pcd8544.bias = cfg.LCD_BIAS
            self.pcd8544.contrast = cfg.LCD_CONTRAST
            self.pcd8544.fill(self.white)
            self.pcd8544.invert = True
            if force_show:
                self.pcd8544.show()

    def show_image(self):
        if self.enabled:
            with self.sema:
                self.pcd8544.image(self.image)
                self.pcd8544.show()


#-------------------------------------------------------------------------
# Class to handle the PCD8544 display (old Adafruit_Nokia_LCD library).
#-------------------------------------------------------------------------
class lcd_pcd8544_old:

    def __init__(self, cfg):
        logging.info('Using Adafruit_Nokia_LCD library')
        import Adafruit_Nokia_LCD as LCD
        import Adafruit_GPIO.SPI as SPI
        self.device = '/dev/spidev%d.%d' % (cfg.LCD_SPI_DEVICE, cfg.LCD_SPI_PORT)
        self.enabled = cfg.LCD_ENABLED
        self.black = cfg.LCD_BLACK
        self.white = cfg.LCD_WHITE
        if self.enabled and not os.access(self.device, os.W_OK):
            logging.error('Device %s is not accessible, disabling LCD' % (self.device,))
            self.enabled = False
        if self.enabled:
            LCD_SPI_PORT = 0
            self.pcd8544 = LCD.PCD8544(cfg.LCD_DC, cfg.LCD_RST, spi=SPI.SpiDev(cfg.LCD_SPI_PORT, cfg.LCD_SPI_DEVICE, max_speed_hz=4000000))
            self.reset(force_show=True)
        self.width = 84
        self.height = 48
        # Create an image buffer and get the drawable object.
        self.image = Image.new('1', (self.width, self.height))
        self.draw = ImageDraw.Draw(self.image)
        # Draw a white filled box to clear the image.
        self.draw.rectangle((0, 0, self.width, self.height), outline=self.white, fill=self.white)
        # Load some fonts.
        self.font_bcmp16 = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_compressed_bold.ttf'), 16)
        self.font_bcnd16 = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_condensed_bold.ttf'),  16)
        self.font_bcmp8  = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_compressed_bold.ttf'),  8)
        self.font_bcnd8  = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_condensed_bold.ttf'),   8)
        self.font_cnd8   = ImageFont.truetype(os.path.join(FONTS_DIR, 'pf_tempesta_seven_condensed.ttf'),        8)
        # Load some icons and convert to 1 bit color.
        self.icon = {}
        self.icon['fire']    = Image.open(os.path.join(ICONS_DIR, 'fire.ppm')).convert(mode='1')
        self.icon['blank']   = Image.open(os.path.join(ICONS_DIR, 'blank.ppm')).convert(mode='1')
        self.icon['ethlink'] = Image.open(os.path.join(ICONS_DIR, 'ethlink.ppm')).convert(mode='1')
        for n in (0, 25, 50, 75, 100):
            icon = 'signal%03d' % (n,)
            file = 'signal%03d.ppm' % (n,)
            self.icon[icon] = Image.open(os.path.join(ICONS_DIR, file)).convert(mode='1')
        # Threading semaphore to access the LCD.
        self.sema = threading.BoundedSemaphore()
        self.show_image()
        self.redraw_network_data = True

    def reset(self, force_show=False):
        # Sometimes the LCD gets corrupted (power problem?): workaround.
        if self.enabled:
            logging.debug('Reset LCD display')
            self.redraw_network_data = True
            self.pcd8544.begin(contrast=cfg.LCD_CONTRAST)
            self.pcd8544.clear()
            if force_show:
                self.pcd8544.display()

    def show_image(self):
        if self.enabled:
            with self.sema:
                self.pcd8544.image(self.image)
                self.pcd8544.display()



#-------------------------------------------------------------------------
# Check if NTP server on localhost has a valid reference time.
#-------------------------------------------------------------------------
def ntp_check_sync():
    global thermostat

    valid_server_stratum = valid_reference_timestamp = False
    sync_age = None
    try:
        c = ntplib.NTPClient()
        response = c.request('127.0.0.1', version=3)
        # From ntplip response.stratum is
        #   0 = unspecified/invalid, 16 = unsynchronized
        #   1 = primary reference, 2-15 = secondary reference,
        if 0 < response.stratum < 16:
            valid_server_stratum = True
        if response.ref_timestamp > 0.0:
            valid_reference_timestamp = True
            sync_age = time.time() - response.ref_time
    except Exception as ex:
        logging.error('Exception in NTP request: %s' % (ex.__class__.__name__,))

    if not valid_reference_timestamp or not valid_server_stratum:
        if thermostat.ntp_status != 'NTP_ERROR':
            logging.error('NTP not syncronized, system time is unknown')
        thermostat.ntp_status = 'NTP_ERROR'
    else:
        if sync_age == None:
            thermostat.ntp_status = 'NTP_WARNING'
            logging.warning('NTP reference time is unknown')
        elif sync_age > NTP_MAX_AGE:
            thermostat.ntp_status = 'NTP_WARNING'
            logging.warning('NTP reference time is %d seconds old' % (int(sync_age),))
        else:
            if thermostat.ntp_status != 'NTP_OK':
                logging.info('NTP is now syncronized')
            thermostat.ntp_status = 'NTP_OK'


#-------------------------------------------------------------------------
# Handler for TCP request.
#-------------------------------------------------------------------------
class socket_tcp_handler(socketserver.StreamRequestHandler):

    # Allow very short time for client to send command.
    timeout = 5

    def handle(self):
        try:
            self.data = self.request.recv(1024).strip().decode('utf-8')
            msg = 'Received command "%s" from TCP client %s' % (self.data, self.client_address[0])
            logging.info(msg)
            if self.data.upper() == 'STATS':
                self.request.sendall(get_stats().encode('utf-8'))
            elif self.data.upper() == 'MODES':
                reply = ",".join([v for (k, v) in sorted(MODES.items())])
                self.request.sendall(reply.encode('utf-8'))
            elif self.data.upper() == 'PROGS':
                reply = ",".join([v for (k, v) in MODES.items() if k not in MANUAL_MODES])
                self.request.sendall(reply.encode('utf-8'))
            elif self.data.upper().startswith('SET '):
                requested_mode = self.data[4:]
                if requested_mode in MODES.values():
                    # Search MODES dictionary key by value.
                    n = dict((v, k) for k, v in MODES.items())[requested_mode]
                    msg = 'Mode "%s" = "%d"' % (requested_mode, n)
                    logging.info(msg)
                    reply = 'OK: Setting mode "%s"' % (requested_mode,)
                    self.request.sendall(reply.encode('utf-8'))
                    mode_change(n)
                else:
                    reply = 'ERROR: Mode "%s" does not exists' % (requested_mode,)
                    self.request.sendall(reply.encode('utf-8'))
            else:
                self.request.sendall('Unknown command\n'.encode('utf-8'))
        except (socket.timeout):
            logging.error('Socket timeout')
        except Exception as ex:
            logging.error('Unexpected error in socket handling: %s' % (ex.__class__.__name__,))
        finally:
            self.request.close()


#-------------------------------------------------------------------------
# Prepare shared memory directory (so some sanity checks).
#-------------------------------------------------------------------------
def shm_initialize():

    # Check/create shared memory directory.
    if os.path.islink(SHM_DIR):
        logging.warning(u"Not using unsafe symbolic link '%s'" % (SHM_DIR))
        return
    if not os.path.exists(SHM_DIR):
        logging.debug(u"Creating shared memory directory '%s'" % (SHM_DIR))
        try:
            os.mkdir(SHM_DIR, 0o755)
        except:
            logging.error(u"Cannot create shared memory directory '%s'" % (SHM_DIR))
    if not os.path.isdir(SHM_DIR):
        logging.error(u"Problem using shared memory directory '%s'" % (SHM_DIR))
        return

    # Check/create RRD directory.
    if os.path.islink(SHM_RRA):
        logging.warning(u"Removing unsafe symbolic link '%s'" % (SHM_RRA))
        try:
            os.remove(SHM_RRA)
        except:
            logging.error(u"Cannot remove symbolic link '%s'" % (SHM_RRA))
            logging.warning(u"Unsafe symbolic link '%s' still exists!" % (SHM_RRA))
    if not os.path.isdir(SHM_RRA):
        try:
            os.mkdir(SHM_RRA, 0o755)
        except:
            logging.error(u"Cannot create directory '%s'" % (SHM_RRA))


#-------------------------------------------------------------------------
# Load programmed temperatures from file. Return a sorted list.
#-------------------------------------------------------------------------
def load_program(prog_n):
    global cfg

    filename = os.path.join(DATA_DIR, "%s.txt" % (MODES[prog_n]))
    # Make a dictionary of {time: temperature} to avoid duplicate keys,
    # fill it with at least the first value.
    temperatures = {0: cfg.DEFAULT_TEMPERATURE}
    try:
        f = open(filename, "r")
    except:
        logging.error(f'Error reading file "{filename}"')
    else:
        try:
            p = re.compile("^(\d)\s+(\d\d):(\d\d)\s+(\d+\.\d+)$")
            n = 0
            for line in f.readlines():
                n += 1
                line = line.strip()
                if line.startswith("#") or line == "":
                    continue
                m = p.match(line.strip())
                if m:
                    weekday = int(m.group(1))
                    hours   = int(m.group(2))
                    minutes = int(m.group(3))
                    temp    = float(m.group(4))
                    if weekday < 0 or weekday > 6:
                        logging.warning(u"Program '%s': invalid day of week at line %d" % (MODES[prog_n], n))
                        continue
                    if hours < 0 or hours > 23:
                        logging.warning(u"Program '%s': invalid hours at line %d" % (MODES[prog_n], n))
                        continue
                    if minutes < 0 or minutes > 59:
                        logging.warning(u"Program '%s': invalid minutes at line %d" %(MODES[prog_n], n))
                        continue
                    time_minute = weekday * (24 * 60) + hours * 60 + minutes
                    temperatures[time_minute] = temp
                else:
                    logging.warning(u"Program '%s': invalid format at line %d" % (MODES[prog_n], n))
            f.close()
        except:
            pass

    # Make a sorted list, for bisect searches.
    program = []
    for minute in sorted(temperatures.keys()):
        program.append((minute, temperatures[minute]))
    return program


#-------------------------------------------------------------------------
# (Re)load all programs from files.
#-------------------------------------------------------------------------
def read_heating_programs():
    global thermostat

    logging.info('Reading heating programs from files')
    for m in sorted(MODES):
        if m in MANUAL_MODES:
            continue
        else:
            thermostat.programs[m] = load_program(m)


#-------------------------------------------------------------------------
# Search programs from programmed temperature.
#-------------------------------------------------------------------------
def programmed_temp(time):
    global cfg, thermostat

    if thermostat.current_mode in MANUAL_MODES:
        return None
    elif cfg.NTP_IS_MANDATORY and thermostat.ntp_status == 'NTP_ERROR':
        return cfg.DEFAULT_TEMPERATURE
    else:
        program = thermostat.programs[thermostat.current_mode]
        minute = time.tm_wday * (24 * 60) + time.tm_hour * 60 + time.tm_min
        logging.debug('Searching minute %s in program "%s"' % (minute, MODES[thermostat.current_mode]))
        keys = [r[0] for r in program]
        if minute >= keys[-1]:
            index = len(keys) - 1
        else:
            index = bisect.bisect_right(keys, minute) - 1
        return program[index][1]


#-------------------------------------------------------------------------
# Read gauge1 float value, return None if not available or error.
#-------------------------------------------------------------------------
def gauge1_read():
    global cfg, thermostat

    new_value = None
    try:
        f = open(cfg.TEMP_SENSOR, 'r')
    except Exception as ex:
        logging.error('Exception opening temperature sensor: %s' % (ex.__class__.__name__,))
    else:
        try:
            data = f.readline().split()
            # 21 01 4b 46 7f ff 0f 10 4b : crc=4b YES
            if data[11] != 'YES':
                logging.error('Bad CRC from temperature sensor: "%s %s"' % (data[10], data[11]))
            else:
                data = f.readline().split()
                # 21 01 4b 46 7f ff 0f 10 4b t=18062
                logging.debug('Temperature raw data is "%s"' % (data[9],))
                if data[9].startswith("t="):
                    try:
                        new_value = float(data[9][2:]) / 1000
                    except:
                        logging.error('Invalid temperature data: "%s"' % (data[9],))
                        new_value = None
                else:
                    logging.error('Invalid temperature data: "%s"' % (data[9],))
        except Exception as ex:
            logging.error('Reading temperature sensor: %s' % (ex.__class__.__name__,))
        finally:
            f.close()
    thermostat.gauge1_value = new_value

    if thermostat.gauge1_value != None:
        logging.debug('Value of gauge1 is %.2f' % (thermostat.gauge1_value,))
    else:
        logging.debug('Error reading gauge1')
    return thermostat.gauge1_value


#-------------------------------------------------------------------------
# Show system info, e.g. CPU load, etc.
#-------------------------------------------------------------------------
def display_sys(redraw=True):
    global lcd

    load = 'CPU: %.2f' % (os.getloadavg()[1],)  # Load average over the last 5 minutes
    lcd.draw.rectangle((0, 32, 43, 38), outline=lcd.white, fill=lcd.white)
    lcd.draw.text((0, 28), load[0:10], font=lcd.font_cnd8, fill=lcd.black)
    if redraw:
        lcd.show_image()


#-------------------------------------------------------------------------
# Show temperature (gauge1) on LCD.
#-------------------------------------------------------------------------
def display_temperature(redraw=True):
    global cfg, lcd, thermostat

    # Range from -55.0 to 125.0 Celsius.
    if isinstance(thermostat.gauge1_value, int) or isinstance(thermostat.gauge1_value, float):
        if cfg.DEGREES_UNIT == 'F':
            display_value = (thermostat.gauge1_value * 9.0 / 5.0) + 32.0
        else:
            display_value = thermostat.gauge1_value
        label = '%.1f °%s' % (display_value, cfg.DEGREES_UNIT)
    else:
        label = 'N/A °%s' % (cfg.DEGREES_UNIT,)
    lcd.draw.rectangle((0, 0, lcd.width - 1, 13), outline=lcd.white, fill=lcd.white)
    lcd.draw.text((0, -8), label, font=lcd.font_bcnd16, fill=lcd.black)
    if redraw:
        lcd.show_image()


#-------------------------------------------------------------------------
# Show status of switch1 (fire) on LCD.
#-------------------------------------------------------------------------
def display_switch1(status, redraw=True):
    global lcd

    if status:
        icon = 'fire'
    else:
        icon = 'blank'
    lcd.image.paste(lcd.icon[icon], (lcd.width - 32, lcd.height - 16))
    if redraw:
        lcd.show_image()


#-------------------------------------------------------------------------
# Get carrier status from network interface.
#-------------------------------------------------------------------------
def carrier_status(ifname):

    carrier = 0
    try:
        with open(IFACE_CARRIER % (ifname,), 'r') as f:
           carrier = int(f.readline().strip())
    except Exception as ex:
        logging.debug('Exception reading interface carrier: %s' % (ex.__class__.__name__,))
    else:
        logging.debug('Carrier of interface %s is %s' % (ifname, carrier))
    return carrier


#-------------------------------------------------------------------------
# Return the quality (0 - 100) of wireless interface link.
#-------------------------------------------------------------------------
def wifi_quality(ifname):
    global cfg

    strength = 0
    ifname_tag = ifname + ':'
    try:
        with open(WIFI_DATA, 'r') as f:
            for line in f.readlines():
                data = line.strip().split()
                if data[0] == ifname_tag:
                    logging.debug('WiFi signal quality for %s is "%s" (raw data)' % (ifname, data[2]))
                    try:
                        strength = int(float(data[2]) / cfg.WIFI_QUALITY_SCALE * 100)
                    except:
                        strength = 0
                    if strength < 0:   strength = 0
                    if strength > 100: strength = 100
                    break
    except Exception as ex:
        logging.error('Exception getting WiFi quality: %s' % (ex.__class__.__name__,))
    return strength


#-------------------------------------------------------------------------
# Get the network signal strength, range 0 - 100 (Ethernet is 100%).
#-------------------------------------------------------------------------
def network_status_update():
    global cfg, thermostat

    if carrier_status(cfg.WIRED_IFACE) == 1:
        thermostat.network_iface = cfg.WIRED_IFACE
        thermostat.network_strength = 100
    elif carrier_status(cfg.WIFI_IFACE) == 1:
        thermostat.network_iface = cfg.WIFI_IFACE
        thermostat.network_strength = wifi_quality(cfg.WIFI_IFACE)
    else:
        thermostat.network_iface = None
        thermostat.network_strength = 0
    try:
        thermostat.network_addr = netifaces.ifaddresses(thermostat.network_iface)[netifaces.AF_INET][0]['addr']
    except:
        thermostat.network_addr = 'Address N/A'


#-------------------------------------------------------------------------
# Show network data on LCD: IP address, signal strength diagram, etc.
#-------------------------------------------------------------------------
def display_network(redraw=True):
    global cfg, lcd, thermostat

    old_iface    = thermostat.network_iface
    old_addr     = thermostat.network_addr
    old_strength = thermostat.network_strength
    network_status_update()

    # A redraw of network data is forced, e.g. after LCD reset.
    if lcd.redraw_network_data:
        old_iface    = None
        old_addr     = None
        old_strength = None
        lcd.redraw_network_data = False

    # IP address.
    if thermostat.network_addr != old_addr:
        lcd.draw.rectangle((0, 24, 80, 30), outline=lcd.white, fill=lcd.white)
        lcd.draw.text((0, 20), 'IP: %s' % (thermostat.network_addr), font=lcd.font_cnd8, fill=lcd.black)
        if redraw:
            lcd.show_image()

    # Signal strength.
    if thermostat.network_strength != old_strength or thermostat.network_iface != old_iface:
        if thermostat.network_iface == cfg.WIFI_IFACE:
            normalized = int(round((thermostat.network_strength / 25.0), 0) * 25)
            icon = 'signal%03d' % (normalized,)
        elif thermostat.network_iface == cfg.WIRED_IFACE:
            icon = 'ethlink'
        else:
            icon = 'blank'
        lcd.image.paste(lcd.icon[icon], (lcd.width - 16, lcd.height - 16))
        if redraw:
            lcd.show_image()


#-------------------------------------------------------------------------
# Show mode (program, manual ON, manual OFF).
#-------------------------------------------------------------------------
def display_mode(redraw=True):
    global cfg, lcd, thermostat

    if thermostat.current_mode in MANUAL_MODES:
        label = MODES[thermostat.current_mode]
    else:
        label = '%s => %.1f °%s' % (MODES[thermostat.current_mode], thermostat.gauge1_required, cfg.DEGREES_UNIT)

    lcd.draw.rectangle((0, 15, 83, 21), outline=lcd.white, fill=lcd.white)
    lcd.draw.text((0, 11), label, font=lcd.font_bcnd8, fill=lcd.black)
    if redraw:
        lcd.show_image()


#-------------------------------------------------------------------------
# Show the clock on LCD.
#-------------------------------------------------------------------------
def display_clock(redraw=True):
    global lcd, thermostat

    lcd.draw.rectangle((0, 41, 46, lcd.height - 1), outline=lcd.white, fill=lcd.white)
    time_label = time.strftime('%H:%M:%S')
    if thermostat.ntp_status != 'NTP_OK': time_label += ' !'
    lcd.draw.text((0,37), time_label, font=lcd.font_bcmp8, fill=lcd.black)
    if redraw:
        lcd.show_image()


#-------------------------------------------------------------------------
# Cycle through all modes (manual, prog, etc.)
#-------------------------------------------------------------------------
def mode_cycle():
    global thermostat

    if thermostat.current_mode >= (len(MODES) - 1):
        mode_change(0)
    else:
        mode_change(thermostat.current_mode + 1)


#-------------------------------------------------------------------------
# Set a new manual or program mode (index of MODES dictionary).
#-------------------------------------------------------------------------
def mode_change(mode):
    global thermostat

    if (not mode in MODES.keys()):
        logging.error('Invalid mode %d requested' % (mode,))
        return

    thermostat.current_mode = mode;
    logging.info('Changing mode to "%s"' % (MODES[thermostat.current_mode],))

    # Write down current mode to file.
    filename = os.path.join(DATA_DIR, CURR_MODE)
    try:
        f = open(filename, 'w')
        f.write("%d\n" % (thermostat.current_mode))
        f.close()
    except:
        logging.error('Error writing file "%s"' % (filename,))

    thermostat.gauge1_required = programmed_temp(time.localtime())
    export_status()
    display_mode()


#-------------------------------------------------------------------------
# Interrupt driven handler for button #1 press.
#-------------------------------------------------------------------------
def button1_handler(gpio):
    global lcd, thermostat

    previous_press = thermostat.button1_last_press
    thermostat.button1_last_press = time.time()
    if (thermostat.button1_last_press - previous_press) > 300:
        logging.info('Executing button1_handler(): LCD reset')
        # Sometimes the LCD just blanks, may be due electromagnetic
        # interferences on the GPIOs.
        # Workaround: the first button press after a long time is
        # used to reset the LCD instead of cycling program mode.
        lcd.reset()
    else:
        logging.info('Executing button1_handler(): cycle program mode')
        mode_cycle()

#-------------------------------------------------------------------------
# Exec by timer: update temp sensor (gauge1) and relay switch (switch1).
# Update the LCD content but don't redraw it: the clock update will do.
#-------------------------------------------------------------------------
def update_thermostat():
    global cfg, thermostat

    logging.debug('Executing update_thermostat()')
    # Update system information data display.
    display_sys(redraw=False)
    # Update network data display.
    display_network(redraw=False)
    # Update temperature display.
    thermostat.gauge1_value = gauge1_read()
    display_temperature(redraw=False)
    # Update mode display.
    thermostat.gauge1_required = programmed_temp(time.localtime())
    display_mode(redraw=False)
    logging.debug('Temperature is %s, required %s (±%.1f)' %(thermostat.gauge1_value, thermostat.gauge1_required, cfg.TEMP_HYSTERESIS))

    if thermostat.current_mode in MANUAL_MODES:
        # Manual modes.
        if thermostat.current_mode == MODE_MANUAL_OFF:
            manual_state = cfg.RELAY_OFF
        else:
            manual_state = cfg.RELAY_ON
        if manual_state != thermostat.switch1_state:
            hyst1 = time.time() - thermostat.switch1_last_change
            hyst2 = time.time() - thermostat.button1_last_press
            if (hyst1 < cfg.MANUAL_HYSTERESIS or hyst2 < cfg.BUTTON1_HYSTERESIS):
                logging.debug('Waiting hysteresis time before toggling switch1')
            else:
                thermostat.switch1_state = manual_state
                logging.info('Mode is "%s", setting switch1 to %s' % (MODES[thermostat.current_mode], thermostat.switch1_state == cfg.RELAY_ON))
                # Update switch1 status display.
                display_switch1(thermostat.switch1_state == cfg.RELAY_ON, redraw=False)
                GPIO.output(cfg.SWITCH1_GPIO, thermostat.switch1_state)
                thermostat.switch1_last_change = time.time()
    elif (thermostat.gauge1_value != None and thermostat.gauge1_required != None):
        # Program modes.
        if (thermostat.gauge1_value >= (thermostat.gauge1_required + cfg.TEMP_HYSTERESIS) and thermostat.switch1_state == cfg.RELAY_ON) or (thermostat.gauge1_value < (thermostat.gauge1_required - cfg.TEMP_HYSTERESIS) and thermostat.switch1_state == cfg.RELAY_OFF):
            hyst1 = time.time() - thermostat.switch1_last_change
            hyst2 = time.time() - thermostat.button1_last_press
            if (hyst1 < cfg.SWITCH1_HYSTERESIS or hyst2 < cfg.BUTTON1_HYSTERESIS):
                logging.debug('Waiting hysteresis time before toggling switch1')
            else:
                thermostat.switch1_state = not thermostat.switch1_state
                logging.info('Temperature is %.2f, "%s" requires %.2f (±%.1f), setting switch1 to %s' % (thermostat.gauge1_value, MODES[thermostat.current_mode], thermostat.gauge1_required, cfg.TEMP_HYSTERESIS, thermostat.switch1_state == cfg.RELAY_ON))
                # Update switch1 status display.
                display_switch1(thermostat.switch1_state == cfg.RELAY_ON, redraw=False)
                GPIO.output(cfg.SWITCH1_GPIO, thermostat.switch1_state)
                thermostat.switch1_last_change = time.time()

    export_status()


#-------------------------------------------------------------------------
# Handle SIGTERM and SIGINT signals.
#-------------------------------------------------------------------------
def program_exit(signum, frame):
    global thermostat

    logging.info('Received exit signal, acting shortly...')
    thermostat.exit_program = True


#-------------------------------------------------------------------------
# Handle SIGHUP signal: reload config and programs.
#-------------------------------------------------------------------------
def program_hup(signum, frame):
    global cfg, lcd

    logging.info('Received HUP signal')
    cfg = read_config(CFG_FILE)
    # Eventually change logging format, cannot change logging
    # handler (stdout, file or syslog) for a running process.
    log_handler = logging.getLogger().handlers[0]
    log_handler.setFormatter(logging.Formatter(cfg.LOG_FORMAT, cfg.LOG_FMT_DATE))
    read_heating_programs()
    lcd.reset()

#-------------------------------------------------------------------------
# Handle SIGUSR1 signal (cycle mode).
#-------------------------------------------------------------------------
def program_usr1(signum, frame):
    logging.info(u"Received USR1 signal, simulate button #1 press")
    mode_cycle()

#-------------------------------------------------------------------------
# Handle SIGUSR2 signal (re-initialize LCD).
#-------------------------------------------------------------------------
def program_usr2(signum, frame):
    global lcd

    logging.info('Received USR2 signal, LCD display reset')
    lcd.reset()

#-------------------------------------------------------------------------
# Return internal data (from global variables) as a string.
#-------------------------------------------------------------------------
def get_stats():
    global cfg, thermostat

    timestamp = int(time.time())
    temp_measured = temp_required = None
    if isinstance(thermostat.gauge1_value,    float): temp_measured = int(thermostat.gauge1_value    * 1000)
    if isinstance(thermostat.gauge1_required, float): temp_required = int(thermostat.gauge1_required * 1000)
    mode = MODES[thermostat.current_mode].replace(" ", "_")
    if (thermostat.switch1_state == cfg.RELAY_ON):
        relay_state = 1
    else:
        relay_state = 0
    return "%s %s %s %s %s %s %s %s %s" % (timestamp, thermostat.ntp_status, thermostat.network_iface, thermostat.network_addr, thermostat.network_strength, mode, temp_measured, temp_required, relay_state)


#-------------------------------------------------------------------------
# Expose internal data through a file (use shared memory!).
#-------------------------------------------------------------------------
def export_status():
    global lcd

    stats_string = get_stats() + "\n"
    if os.path.isdir(SHM_DIR):
        try:
            tmpf = tempfile.NamedTemporaryFile('w+b', dir=SHM_DIR, prefix=SHM_STATS, delete=False)
            tmpf.write(stats_string.encode('utf-8'))
            tmpf.close
            os.chmod(tmpf.name, 0o644)
            os.rename(tmpf.name, os.path.join(SHM_DIR, SHM_STATS))
            lcd.image.save(SHM_IMG, 'PNG')
        except Exception as ex:
            logging.error('Error writing data in shared memory files: %s' % (ex.__class__.__name__,))


#-------------------------------------------------------------------------
# Initialize logging.
#-------------------------------------------------------------------------
def log_open():
    global cfg

    if not cfg.BE_DAEMON:
        # Log to stdout.
        handler = logging.StreamHandler(stream=sys.stdout)
    elif cfg.LOG_TO_FILE:
        # Log to file.
        handler = logging.FileHandler(filename=cfg.LOG_TO_FILE)
    else:
        # Log to syslog.
        handler = logging.handlers.SysLogHandler(address='/dev/log')
    handler.setFormatter(logging.Formatter(cfg.LOG_FORMAT, cfg.LOG_FMT_DATE))
    logger = logging.getLogger()
    # Remove existing handlers (eventually added by modules).
    while logger.hasHandlers():
        logger.removeHandler(logger.handlers[0])
    logger.setLevel(cfg.LOG_LEVEL)
    logger.addHandler(handler)


#-------------------------------------------------------------------------
# Main program loop.
#-------------------------------------------------------------------------
def program_main():
    global cfg, lcd, thermostat

    os.umask (0o022)
    shm_initialize()
    read_heating_programs()

    logging.info('Setting GPIO mode and default state')
    # GPIO access using Raspberry Pi Python library.
    GPIO.setmode(GPIO.BCM)
    # Suppress "This channel is already in use" warning, if restart after crash.
    GPIO.setwarnings(False)
    # Setup relays GPIOs as output and turn off them.
    GPIO.setup((cfg.SWITCH1_GPIO, cfg.SWITCH2_GPIO), GPIO.OUT)
    GPIO.output((cfg.SWITCH1_GPIO, cfg.SWITCH2_GPIO), cfg.RELAY_OFF)
    # Set button GPIO as input, default state via software PULL-UP/DOWN.
    if cfg.BUTTON1_ACTIVE_HIGH:
        GPIO.setup(cfg.BUTTON1_GPIO, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
    else:
        GPIO.setup(cfg.BUTTON1_GPIO, GPIO.IN, pull_up_down=GPIO.PUD_UP)

    thermostat.current_mode = MODE_DEFAULT
    filename = os.path.join(DATA_DIR, CURR_MODE)
    logging.info('Reading current mode from "%s"' % (filename))
    try:
        f = open(filename, 'r')
        thermostat.current_mode = int(f.read().strip())
        f.close()
    except:
        logging.error('Error reading file "%s"' % (filename))
    logging.info('Mode is "%s"' % (MODES[thermostat.current_mode]))

    thermostat.button1_last_press = time.time()
    if cfg.BUTTON1_ENABLED:
        logging.info('Adding button #1 handler')
        if cfg.BUTTON1_ACTIVE_HIGH:
            GPIO.add_event_detect(cfg.BUTTON1_GPIO, GPIO.RISING, callback=button1_handler, bouncetime=300)
        else:
            GPIO.add_event_detect(cfg.BUTTON1_GPIO, GPIO.FALLING, callback=button1_handler, bouncetime=300)

    thermostat.switch1_state = cfg.RELAY_OFF
    thermostat.switch1_last_change = time.time() - cfg.SWITCH1_HYSTERESIS

    # Threads to update the LCD display and the thermostat state.
    logging.info('Starting timer #1 "display_clock"')
    timer1_thread = forever_timer('display_clock', 1, display_clock)
    logging.info('Starting timer #2 "update_thermostat" for temp sensor and relay switch')
    timer2_thread = forever_timer('update_thermostat', 5, update_thermostat)

    # Initialize a TCP socket and run it in a separate thread.
    tcp_server = None
    if cfg.TCP_PORT != 0:
        logging.info('Starting TCP socket on %s:%s' % (cfg.BIND_ADDR, cfg.TCP_PORT))
        try:
            socketserver.TCPServer.allow_reuse_address = True
            tcp_server = socketserver.TCPServer((cfg.BIND_ADDR, cfg.TCP_PORT), socket_tcp_handler)
            th = threading.Thread(target=tcp_server.serve_forever)
            th.daemon = True
            th.start()
        except Exception as ex:
            logging.error('Cannot open TCP socket: %s' % (ex.__class__.__name__,))
            tcp_server = None


    while not thermostat.exit_program:
        logging.debug('Idle in main loop')
        ntp_check_sync()
        try:
            time.sleep(IDLE_LOOP_TIME)
        except Exception as ex:
            logging.error('Exiting main loop with exception: %s' % (ex.__class__.__name__,))
            break

    if tcp_server != None:
        logging.info('Closing TCP socket')
        tcp_server.socket.close()

    logging.info('Cancelling timers')
    timer2_thread.stop()
    timer1_thread.stop()
    # Allow eventually running handlers to terminate.
    time.sleep(2)

    logging.info('Writing data to shared memory file')
    export_status()

    if lcd.enabled:
        logging.debug('Clearing LCD content')
        lcd.reset(force_show=True)

    logging.info('Cleaning GPIO settings')
    GPIO.cleanup()


#-------------------------------------------------------------------------
# Entry point.
#-------------------------------------------------------------------------
# Read configuration file.
cfg = read_config(CFG_FILE)
# Create an object to store working data.
thermostat = protherm()

# If required: run in foreground and log to stdout.
if len(sys.argv) > 1:
    if sys.argv[1] == '-f':
        cfg.BE_DAEMON = False

# Prepare daemon context.
# TODO: Check why acquire_timeout does not work: measured 3.5 minutes
context = daemon.DaemonContext(
    working_directory = '/tmp',
    umask=0o002,
    pidfile=daemon.pidfile.TimeoutPIDLockFile(
        path=PID_FILE,
        acquire_timeout=2),
    signal_map = {
        signal.SIGHUP:  program_hup,
        signal.SIGINT:  program_exit,
        signal.SIGTERM: program_exit,
        signal.SIGUSR1: program_usr1,
        signal.SIGUSR2: program_usr2 }
)

if cfg.BE_DAEMON:
    log_opened = False
    try:
        with context:
            log_open()
            log_opened = True
            logging.info('Running as daemon')
            if cfg.OLD_LCD_LIBRARY:
                lcd = lcd_pcd8544_old(cfg)
            else:
                lcd = lcd_pcd8544(cfg)
            program_main()
    except Exception as ex:
        if not log_opened:
            log_open()
        logging.error('Exception type %s: %s' % (ex.__class__.__name__, ex.__str__()))
else:
    log_open()
    if cfg.OLD_LCD_LIBRARY:
        lcd = lcd_pcd8544_old(cfg)
    else:
        lcd = lcd_pcd8544(cfg)
    logging.info('Running in foreground')
    signal.signal(signal.SIGHUP,  program_hup)
    signal.signal(signal.SIGINT,  program_exit)
    signal.signal(signal.SIGTERM, program_exit)
    signal.signal(signal.SIGUSR1, program_usr1)
    signal.signal(signal.SIGUSR2, program_usr2)
    program_main()

logging.info('Exiting program')
